#
# Thinking in JAVA 笔记及后感：* 第7章：复用类
#

### 复用类两种方式： 组合 + 继承 + 代理（组合与继承的中庸之道）


### toString()
    每一个非基本数据类型对象都有一个toString()方法，当该对象需要被用于作为字符串的时候该方法被自动调用。
    重写toString方法可以，让我们让对象按照自己的方式来输出对象的某些信息。

## 每一个类都可以写一个main方法，有利于对类进行单元测试。
    java ClassName xxx参数 ：调用ClassName的main函数，参数传入main的String[] args。

### extends 继承
    super.function() 调用父类的方法，可以放在任何地方。
    super() 使用父类的构造，只能放在构造函数的最开头！当父类构造不是默认带参数的时候，就必须调用父类的构造函数。
    构建对象的时候，先构造父类在构造子类！

## 代理
    代理类private的持有被代理类的对象，复写被代理对象的方法（可以只复写你想要代理的部分！）。
#为什么要用代理？
    比如我想要一个类，它与某个已有的类高度耦合，但是我不想使用它的全部方法，只想使用其部分方法，而且是通过代理类对象直接使用，那就应该使用代理，
    继承会包含其所有方法，组合必须获取到对象才能使用其方法。代理很好的解决了这矛盾。而且也符合开闭原则！
    代理主要相对于继承和组合有了更好的控制力。

## 什么时候用继承
    is-a: 针对某个类需要该类的特殊版本，这时候用继承。我这个类和已有类需要能提供一样的接口。
## 什么时候用组合
    has-a:只希望使用现有类的功能，并不是希望同时自己也暴露现有类一样的接口。我只想用该对象，不想要和其一样的接口。持有的组合对象建议private

## 向上转型
    就是父类可以接受子类的对象。

### final
    通常代表无法改变的！
    ## final 数据：
               * 必须被初始化，并只能被初始化一次！
               * 基本数据类型代表常量，引用代表引用的指向不能变化，但是被引用的对象的值可以改变。
               * static final xxx编译时常量一般大写格式。
               * 空白final：定义的时候不给其初值，在构造器中给其赋值！（final需要被保证在使用前必须被初始化！所以必须在域定义初或者构造器中初始化）
               * @see：chapter_7/BlankFinal.java
    ## final 参数：
               * 无法在方法体中修改参数中引用的指向！
    ## final 方法：
               * 不可以被子类覆盖，当子类override final方法的话语法检查都不通过。final方法相当于private被隐藏在当前类内部。
    ## final 类：
               * 不能被继承！


### static 是发生在类加载上的

Java程序执行过程：分为两步：类加载+对象创建
（类加载：相关class文件加载）：
1. 使用java运行一个类，首先试图访问ClassXX.main()方法（第一个static方法），然后加载ClassXX.class文件。
2. 如果ClassXX有父类，那么继续加载其父类。以此类推！
3. 直到加载出所有与main入口类相关的类（它的父类，父类的父类等）。
（类加载：static初始化，只初始化一次）：
4. 从其根基类开始，对其static域按照顺序进行初始化！直至初始化完所有的static依次都被初始化。
（至此类的加载工作完毕了，下面就进入main函数，继续执行。一般main函数中来创建类的对象，如果该类没有被加载，则继续加载）
（对象创建：类加载完毕后就可以根据类来创建对象了。）
1. 获取内存，将内存全部置为0，对象中的所有属性都是默认值（内存为0时候的默认值：null，0，false...）：全清0
2. 从最父类开始，按照申明顺序初始化非static的属性；
3. 调用父类的构造函数；
4. 初始化当前类的非static属性；
5. 调用当前类的构造函数，对属性再次初始化。（对继承体系类中的每一层都初始化完成后初始化下一层）
