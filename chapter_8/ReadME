#
# Thinking in JAVA 笔记及后感：* 第8章：多态
#

## 什么是多态？
    Java中父类引用指向子类对象，从而根据指向子类对象的不同，表现出不同的状态。多态来源来源于继承，实现于类方法的覆盖。

## 前期绑定 和 后期绑定
    c中的函数都是前期绑定的，具体执行哪个函数是确定的。
    动态绑定指在运行时根据对象的类型绑定相应的方法。多态就来源于该特性：在程序运行时根据对应的对象的类型，调用合适的方法。（而final作用是关闭动态绑定）

### 重载的本质形式：
    父类对象Father f ； 子类对象Son s；
    f=new Son() f.fun()并不是说程序执行的时候，遇到重载的方法就跑到子类的代码区中执行！
    而是这种赋值操作本身就直接作用在父类代码区，也就说执行fun的时候，都还是在父类代码区中执行的（可能在编译阶段，每一次重载发生都会在父类上反映出来并做记录！）
    我们多态的发生，相当于父类代码区中被重载的方法都被替换了形成一个新类，剩下的操作都是作用这个新类，而不是之前我理解的通过跳转两个类来实现多态！


## 多态最经典的还是工厂模式的应用


### 多态的缺陷：只有普通方法是可以多态的！
##  private和final是无法表现出多态的。
    Java中只有非private的方法才可以被覆盖！private虽然可以在子类中重写（final是不可以的）但是这不是覆盖！
    private本身就隐藏在父类中，自己定义的private也只是隐藏在自己类中，所以不会有多态性！
    ---也就是说在当父类的引用->子类对象时候，在父类中调用子类重写的private方法时候，实际调用的还是父类的。@see:chapter_8/Chapter8.java
## 成员属性和静态方法是无法表现出多态的。
    成员属性不会被多态，什么类型引用，就会调用什么类型的成员属性值。@see:chapter_8/Chapter8.java
    静态方法不会被多态。

## 构造函数是隐式的static，所以构造器也不会多态！--也没法多态，名字都不一样。

### 继承的清理工作
    一般我们寄托于GC来对对象进行回收，但是如果我们想自己手动编写dispose()方法来销毁对象的时候，就要按照一定规范！
    对象的销毁顺序要和初始化顺序相反！
    子类销毁函数执行完了才可以调用父类的销毁函数！
    如果某个对象被多个对象持有并共享，当销毁这些对象的时候不能连带着销毁共享的对象，应该使用引用计数，当共享独享被引用记为0时候才能销毁该对象@see:
    （总之就是与构造过程相逆的过程）

## 编写构造器注意：避免调用其他方法，特别是可能被其子类重载的方法！尽可能简单的让对象进入正常的状态。构造器中唯一可以随便调用而没有危险的就是final/private方法。
    @see:

## 协变返回类型：函数重载但是返回类型可以不一样，早期的jdk返回值要求是一样的现在运行返回同类或者导出类的类型对象。
    @see:

## 纯继承：
    不添加任何新方法的继承。称为is-a，可以完全的替换。
    添加新的方法的只能称为is-like-a，这种情况的要考虑组合是否更好。

### 向上转型会丢失信息，但是是安全的。
    向下转型是不安全的（int）xxx
    Java所有的转型都会经过安全类型检查 RTTI





















