#
# Thinking in JAVA 笔记及后感：* 第5章：初始化与清理
#

### 构造函数
    1. 没有返回值；
    2. 和类名相同；
    3. 用来初始化对象。
    4. 一旦有定义构造函数，编译器就不会给你加上默认构造函数（c++默认构造器好像是一直存在的）

### 重载overload
    1. 唯一条件：函数名相同，参数不同！
    2. 很好理解：你调用一个有重载的函数时候怎么可以区分调用哪一个函数？只有传入不同参数才可以区分！
### 注意：
    重载中的参数如果是基本数据类型，小的类型（低精度）会被自动转换到大的类型（高精度）上去，
    比如：
    f(char) f(int)两个函数，调用f('a')的时候，a会被转换为int调用f(int)！
    所以，最好不要使用节本数据类型做参数，非要使用就一定要注意这种情况！


### this关键字
    a.function()：其实是“发送消息给对象过程”，function是代码区的东西，代码之所以知道要和那个对象传递消息，是因为编译器做了暗箱操作：
    其实a.function的时候，发送的是a.function(a,参数),所以代码才知道和哪个对象通信。
    而在方法内部获取调用对象的引用就是this关键字！this表示当前调用者对象的引用！
    用途：
    1. this.x = x，来显示区分参数；
    2. this(object)，构造函数中调用构造函数。

### static
    static方法就是没有this的方法，他是共享的。可以直接被类调用（static的主要用途）。
### 注意：
    static只可以访问static区域的，不能访问非static区的；
    非static区的却可以访问static区的。
    共享的大家都可以访问，私人的只有私人的可以访问！
    静态的不能作用域局部变量！static不能修饰局部变量

### finalize()
    GC在回收对象之前调用该方法，用来清理一些使用对象过程中可能使用JNI申请的native内存，这些内存无法被GC，所以通过finalize()使得GC前可以free掉申请的内存。finalize()是protect的，只应该发生在GC的时候（即内存要耗尽的，GC有消耗，jvm不到逼不得已不会GC），我们无法控制它的发生，不过多的推荐使用。


### 垃圾回收器GC工作原理
    ## GC对在提高了堆上创建对象的速度（之前在堆上分配对象内存代价是很大的），可以媲美栈上分配内存：
        JVM在GC中会一边回收空间，一边整理压缩堆对象使其排列整齐。“堆指针”只要简单的向前移动到未分配内存的区域就可以为对象分配内存。
    ### GC实现：
        1. 引用计数（未用）：简单速度慢，每个对象都有一个引用计数器，有引用的时候+1，离开被引用的作用域或者该对象的某个引用被置为null的时候就-1. 垃圾回收器会遍历所有的对象，如果引用值为0则清除它。优点：简单，缺点：慢，耗资源，循环引用的时候无法释放内存。
        2. 遍历引用树：Java程序对象只要被使用，在栈区和静态区肯定有引用表现，那就从他们开始，遍历所有的引用，排除所有活的剩下来的就是死的。当执行清理的时候又分为几种：
        1）停止-复制：先暂停程序运行，将所有活的对象紧凑的拷贝到一个新的堆，删除原来的堆。>效率差！垃圾少的时候开销过分（如果少量或者没有产生垃圾，依然会全部拷贝对象）。
        2）标记-清扫：上述停止-复制情况下，增加一步检验：如果没有新的垃圾产生，转到该模式：每找到一个活着的对象就给他加一个标记，标记完成后开始清理没有标记的对象，剩下的不连续的内存再做整理。
        上面两种GC都会暂停程序运行。

## 成员属性会自动初始化，局部变量必须初始化，否则不通过编译。
    对象初始化过程：属性清0 -> 属性初始化 -> 构造函数初始化。（博客有写）

### 数组初始化
    new int[10] //指定大小为10，内部数据为null或者0；
    int[] aa = new int[4]{x,x,x}; //最好在定义的时候就初始化 或者 aa = {1,2,3}

## 可变参数：jdk1.5出现
    function(Object...args) //相当于传入Object[] args，然后再函数内部对args迭代。
    可变参数就是让我们不用再将数据包装成数组然后传入，直接传入对象，编译器内部会自动给我们装成数组！所以我们函数内部获得的其实还是一个数组。
    而且可以什么都不传入。如果只是数组型的参数，是不允许的。
    #注意：在使用可变参数的函数，最好不要出现重载情况，不然参数会混淆：f(int a) f(int...a) -- f(1)执行哪一个？

### 枚举类型
    public enum MyEnum{
        ONE,TWO,THREE,FOUR
    }
    MyEnum e = MyEnum.ONE
    e.ordinal()  //int的数值
    用法@see: chapter_5/Chapter5.java


### 一个对象的构建过程：(博客有)
    比如：new A()
    1. 先初始化静态的类属性 (单个类的静态属性只初始化一次，再次创建该类对象的时候不再执行静态属性的初始化语句)
    2. 初始化非静态的类属性（1和2：没有赋值的赋标准初值，有赋值的用赋值的值。）
    3. 调用构造函数
    4. 用构造函数中赋值覆盖类属性的（上步骤1，2）初始值

    编译角度：
    1. A()发生时候或者直接通过类A访问其静态成员的时候（即需要A的代码时候），构造函数相当于一个静态方法，所有java解释器定位到A.class文件的路径
    2. 虚拟机载入A.class文件，执行所有的静态初始化工作，（ 只在首次加载的时候进行一次！）
    3. 堆上分配A()的内存空间
    4. 内存空间清0，等同于A的所有属性赋予标准初值
    5. 执行A类代码中属性定义的初始化值，等同于初始化属性为定义值
    6. 调用构造器（若继承则更复杂）

static：
    初始化优先级最高：先于main函数的执行，但是最先找的确实是main，main也是静态的。

    关于父类指向子类对象的理解（里氏替换丢失子类信息）纠正：（本质上是对象内存还是老样子，不过使用的时候用类的代码套了个约束）
    Father f = new Son()
    @ 之前错误理解：
        之前在工厂模式啊，参数接收上面看到很多直接用一个父类来接收其所有子类的案例，当时总纳闷当f 引用 Son(）的时候，会不会说是给 f 新制造一个对象，来满足Father类格式的（以前的错误理解）？而因为子类有父类没有的属性和方法，所以本来的Son对象的的信息就丢失了！一旦丢失了那可咋整？原谅我新手这么愚蠢的想法😓，其本质上我没有认清内存上的引用和对象和类型的关系。
    @ 纠正：
        引用是引用，对象是对象。引用在栈上指向堆上的对象。
        f 是一个引用，特别的是它的类型是Father类型的，从而导致了使用它的时候会受制于Father类的代码定义。new Son() 是个对象，而且将一直是一个保留在堆上面的对象。尽管现在Father类型引用指向了一个Son类型对象，但在内存中依然只有一个f引用和一个new Son()对象，并且他们结构不会发生变化！
        当然指向后，f只能使用Father那部分的，但这只是因为f是Father类型引用，编译器根据Father类代码和new Son()这个堆以及Son类(为了多态）来决定f能有的行为。
        所以说，只要在 f 依然引用Son()时候，在其他初f 被强制转换为Son类的时候，new Son()的东西不会有任何丢失，其实相当于f这个引用被强制转换为Son类型，然后一个Son类型的f引用指向了new Son(）这个堆。
        所以以后可以放心的把一个子类对象传递给父类了，不用担心子类因为传递了就会丢失信息（只要将一个Son类型引用指向任何一个引用new Son()对象的引用就行了）！
    引申：
        父类可以引用指向任意子类对象。
        object类型的引用可以引用任何类型的对象，即可以接受任何类型参数。

