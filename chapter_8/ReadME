#
# Thinking in JAVA 笔记及后感：* 第8章：多态
#

## 什么是多态？
    Java中父类引用指向子类对象，从而根据指向子类对象的不同，表现出不同的状态。多态来源来源于继承，实现于类方法的覆盖。

## 前期绑定 和 后期绑定
    c中的函数都是前期绑定的，具体执行哪个函数是确定的。
    动态绑定指在运行时根据对象的类型绑定相应的方法。多态就来源于该特性：在程序运行时根据对应的对象的类型，调用合适的方法。（而final作用是关闭动态绑定），Java中除了static，final，private方法外都是动态绑定的，所以只有动态绑定的方法才能实现多态。static这些就不能被多态。
    多态和动态绑定紧密相关！

### 覆盖实现多态的本质：（动态绑定过程）@see: http://hxraid.iteye.com/blog/428891
    f = new Son()；f.fun() 过程讲起：
    1. 内存中创建一个son对象！
    2. 用一个Father引用去指向该对象；
    3. f.fun() 调用覆盖的函数引发多态：
        3.1. 找到Father方法区中的fun()方法的索引，该索引和其父类或者子类在其类方法区中的索引值一定是一样的。
        3.2. 将fun的索引信息加入到调用该方法的所在类的常亮池表中（常量池解析）
        3.3. 找到引用f所指向的对象Son()，Son()对象中有一个指向son类方法区的指针，根据该指针找到该方法区的相同索引的函数！
        3.4. 调用该函数，完成动态的绑定。

## 多态最经典的还是工厂模式的应用

### 多态的缺陷：只有普通方法是可以多态的！
##  private和final是无法表现出多态的。
    Java中只有非private的方法才可以被覆盖！private虽然可以在子类中重写（final是不可以的）但是这不是覆盖！
    private本身就隐藏在父类中，自己定义的private也只是隐藏在自己类中，所以不会有多态性！
    ---也就是说在当父类的引用->子类对象时候，在父类中调用子类重写的private方法时候，实际调用的还是父类的。@see:chapter_8/Chapter8.java
## 成员属性和静态方法是无法表现出多态的。
    成员属性不会被多态，什么类型引用，就会调用什么类型的成员属性值。@see:chapter_8/Chapter8.java
    静态方法不会被多态。

## 构造函数是隐式的static，所以构造器也不会多态！--也没法多态，名字都不一样。

### 继承的清理工作
    一般我们寄托于GC来对对象进行回收，但是如果我们想自己手动编写dispose()方法来销毁对象的时候，就要按照一定规范！
    对象的销毁顺序要和初始化顺序相反！
    子类销毁函数执行完了才可以调用父类的销毁函数！
    如果某个对象被多个对象持有并共享，当销毁这些对象的时候不能连带着销毁共享的对象，应该使用引用计数，当共享独享被引用记为0时候才能销毁该对象@see:chapter_8/ReferenceCounting.java
    （总之就是与构造过程相逆的过程）

## 编写构造器注意：避免调用其他方法，特别是可能被其子类重载的方法！尽可能简单的让对象进入正常的状态。构造器中唯一可以随便调用而没有危险的就是final/private方法。
    @see:chapter_8/PolyConstructors.java

## 协变返回类型：函数重载但是返回类型可以不一样，早期的jdk返回值要求是一样的现在运行返回同类或者导出类的类型对象。
    @see:chapter_8/CovariantReturn.java

## 纯继承：
    不添加任何新方法的继承。称为is-a，可以完全的替换。
    添加新的方法的只能称为is-like-a，这种情况的要考虑组合是否更好。

### 向上转型会丢失信息，但是是安全的。
    向下转型是不安全的（int）xxx
    Java所有的转型都会经过安全类型检查 RTTI @see:chapter_8/RTTI.java





















